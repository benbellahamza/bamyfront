import { Component, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, Validators, AbstractControl, ValidatorFn } from '@angular/forms';
import { AdminService } from 'app/core/services/admin/admin.service';
import { HistoriqueService } from 'app/core/services/historique/historique.service';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-dashboard-admin',
  standalone: false,
  templateUrl: './dashboard-admin.component.html',
  styleUrls: ['./dashboard-admin.component.css']
})
export class DashboardAdminComponent implements OnInit, OnDestroy {
  // ‚úÖ Configuration pour le layout unifi√©
  navigationItems = [
    {
      label: 'Tableau de bord',
      route: '/admin/dashboard',
      icon: 'dashboard',
      active: true
    },
    {
      label: 'Historique des actions',
      route: '/admin/historique',
      icon: 'history'
    },
    {
      label: 'Gestion des visiteurs',
      route: '/admin/visiteur',
      icon: 'users'
    },
    {
      label: 'Gestion des livraisons',
      route: '/admin/livraison',
      icon: 'truck'
    }
  ];

  // ‚úÖ Donn√©es principales
  utilisateurs: any[] = [];
  historique: any[] = [];
  historiqueDashboard: any[] = [];

  // ‚úÖ Formulaires
  formModif!: FormGroup;
  formReset!: FormGroup;

  // ‚úÖ √âtat des modales
  utilisateurSelectionne: any = null;
  formulaireActif: boolean = false;
  modeForm: 'modifier' | 'reset' | null = null;

  // ‚úÖ Gestion de la visibilit√© des mots de passe
  showPassword: boolean = false;
  showConfirmPassword: boolean = false;

  // ‚úÖ Statistiques
  totalUtilisateurs: number = 0;
  totalActifs: number = 0;
  totalInactifs: number = 0;

  constructor(
    private adminService: AdminService,
    private historiqueService: HistoriqueService,
    private fb: FormBuilder,
    private http: HttpClient
  ) {}

  ngOnInit(): void {
    this.initFormulaires();
    this.chargerDonnees();
  }

  /**
   * ‚úÖ Validateur personnalis√© pour v√©rifier la correspondance des mots de passe
   */
  private passwordMatchValidator(): ValidatorFn {
    return (formGroup: AbstractControl): { [key: string]: any } | null => {
      const password = formGroup.get('newPassword');
      const confirmPassword = formGroup.get('confirmPassword');

      if (!password || !confirmPassword) {
        return null;
      }

      if (password.value && confirmPassword.value && password.value !== confirmPassword.value) {
        return { passwordMismatch: true };
      }

      return null;
    };
  }

  /**
   * ‚úÖ Initialise les formulaires r√©actifs
   */
  private initFormulaires(): void {
    this.formModif = this.fb.group({
      nom: ['', [Validators.required, Validators.minLength(2)]],
      prenom: ['', [Validators.required, Validators.minLength(2)]],
      email: ['', [Validators.required, Validators.email]],
      role: ['', Validators.required]
    });

    this.formReset = this.fb.group({
      newPassword: ['', [Validators.required, Validators.minLength(6)]],
      confirmPassword: ['', [Validators.required]]
    }, { 
      validators: this.passwordMatchValidator()
    });

    // ‚úÖ √âcouter les changements pour mettre √† jour les erreurs de validation
    this.formReset.get('newPassword')?.valueChanges.subscribe(() => {
      this.formReset.get('confirmPassword')?.updateValueAndValidity();
    });
  }

  /**
   * ‚úÖ Charge toutes les donn√©es n√©cessaires
   */
  private chargerDonnees(): void {
    this.chargerUtilisateurs();
    this.chargerHistorique();
  }

  /**
   * ‚úÖ Callback pour le changement de mot de passe du layout unifi√©
   */
  onPasswordChanged(): void {
    console.log('‚úÖ Mot de passe utilisateur chang√© depuis le layout unifi√©');
    // Ici vous pouvez ajouter une logique sp√©cifique si n√©cessaire
    // Par exemple, recharger certaines donn√©es ou afficher une notification
  }

  /**
   * ‚úÖ Toggle la visibilit√© du mot de passe
   */
  togglePasswordVisibility(): void {
    this.showPassword = !this.showPassword;
  }

  /**
   * ‚úÖ Toggle la visibilit√© de la confirmation du mot de passe
   */
  toggleConfirmPasswordVisibility(): void {
    this.showConfirmPassword = !this.showConfirmPassword;
  }

  /**
   * ‚úÖ V√©rifie si les mots de passe correspondent
   */
  get passwordsMatch(): boolean {
    const password = this.formReset.get('newPassword')?.value;
    const confirmPassword = this.formReset.get('confirmPassword')?.value;
    return password === confirmPassword;
  }

  /**
   * ‚úÖ V√©rifie si le formulaire de reset a des erreurs de correspondance
   */
  get hasPasswordMismatchError(): boolean {
    return this.formReset.hasError('passwordMismatch') && 
           this.formReset.get('confirmPassword')?.touched === true;
  }

  /**
   * ‚úÖ Charge la liste des utilisateurs
   */
  chargerUtilisateurs(): void {
    this.adminService.getUtilisateurs().subscribe({
      next: (res) => {
        // Filtrer les utilisateurs valides
        this.utilisateurs = res.filter(u => u.role !== null && u.role !== undefined);
        
        // Calculer les statistiques
        this.calculerStatistiques();
        
        console.log('‚úÖ Utilisateurs charg√©s :', this.utilisateurs.length);
      },
      error: (err) => {
        console.error('‚ùå Erreur chargement utilisateurs :', err);
        this.utilisateurs = [];
        this.calculerStatistiques();
      }
    });
  }

  /**
   * ‚úÖ Charge l'historique des actions
   */
  chargerHistorique(): void {
    this.historiqueService.getHistorique().subscribe({
      next: (data) => {
        this.historique = data || [];

        // Filtrer les actions r√©centes (derni√®res 24h)
        const maintenant = new Date().getTime();
        this.historiqueDashboard = this.historique.filter(action => {
          if (!action.dateAction) return false;
          
          const dateAction = new Date(action.dateAction).getTime();
          const differenceHeures = (maintenant - dateAction) / (1000 * 60 * 60);
          return differenceHeures <= 24;
        }).slice(0, 10); // Limiter √† 10 actions r√©centes

        console.log('‚úÖ Historique charg√© :', this.historique.length, 'actions');
        console.log('‚úÖ Actions r√©centes :', this.historiqueDashboard.length);
      },
      error: (err) => {
        console.error('‚ùå Erreur chargement historique :', err);
        this.historique = [];
        this.historiqueDashboard = [];
      }
    });
  }

  /**
   * ‚úÖ Calcule les statistiques des utilisateurs
   */
  private calculerStatistiques(): void {
    this.totalUtilisateurs = this.utilisateurs.length;
    this.totalActifs = this.utilisateurs.filter(u => u.actif === true).length;
    this.totalInactifs = this.utilisateurs.filter(u => u.actif === false).length;
  }

  /**
   * ‚úÖ Ouvre le formulaire de modification
   */
  ouvrirFormModification(user: any): void {
    if (!user || !user.id) {
      console.error('‚ùå Utilisateur invalide pour modification');
      return;
    }

    this.utilisateurSelectionne = { ...user }; // Cloner l'objet
    this.modeForm = 'modifier';
    this.formulaireActif = true;

    // Pr√©-remplir le formulaire
    this.formModif.patchValue({
      nom: user.nom || '',
      prenom: user.prenom || '',
      email: user.email || '',
      role: user.role || ''
    });

    console.log('‚úÖ Ouverture formulaire modification pour :', user.nom, user.prenom);
  }

  /**
   * ‚úÖ Ouvre le formulaire de reset mot de passe
   */
  ouvrirFormReset(user: any): void {
    if (!user || !user.id) {
      console.error('‚ùå Utilisateur invalide pour reset');
      return;
    }

    this.utilisateurSelectionne = { ...user }; // Cloner l'objet
    this.modeForm = 'reset';
    this.formulaireActif = true;
    
    // R√©initialiser le formulaire et les √©tats de visibilit√©
    this.formReset.reset();
    this.showPassword = false;
    this.showConfirmPassword = false;

    console.log('‚úÖ Ouverture formulaire reset pour :', user.nom, user.prenom);
  }

  /**
   * ‚úÖ Ferme tous les formulaires
   */
  fermerFormulaire(): void {
    this.formulaireActif = false;
    this.modeForm = null;
    this.utilisateurSelectionne = null;
    
    // R√©initialiser les formulaires et les √©tats de visibilit√©
    this.formModif.reset();
    this.formReset.reset();
    this.showPassword = false;
    this.showConfirmPassword = false;

    console.log('‚úÖ Formulaires ferm√©s');
  }

  /**
   * ‚úÖ Soumet la modification d'un utilisateur
   */
  soumettreModification(): void {
    if (this.formModif.invalid) {
      console.error('‚ùå Formulaire de modification invalide');
      this.marquerChampsCommeTouches(this.formModif);
      return;
    }

    if (!this.utilisateurSelectionne?.id) {
      console.error('‚ùå Aucun utilisateur s√©lectionn√© pour modification');
      return;
    }

    const id = this.utilisateurSelectionne.id;
    const donnees = this.formModif.value;

    console.log('üîÑ Modification utilisateur :', id, donnees);

    this.adminService.modifierUtilisateur(id, donnees).subscribe({
      next: (response) => {
        console.log('‚úÖ Utilisateur modifi√© avec succ√®s');
        
        // Recharger les donn√©es
        this.chargerDonnees();
        
        // Fermer le formulaire
        this.fermerFormulaire();
        
        // Optionnel : afficher une notification de succ√®s
        this.afficherNotificationSucces('Utilisateur modifi√© avec succ√®s');
      },
      error: (err) => {
        console.error('‚ùå Erreur modification utilisateur :', err);
        this.afficherNotificationErreur(
          err.error?.message || 'Erreur lors de la modification de l\'utilisateur'
        );
      }
    });
  }

  /**
   * ‚úÖ Soumet la r√©initialisation du mot de passe
   */
  soumettreReset(): void {
    if (this.formReset.invalid) {
      console.error('‚ùå Formulaire de reset invalide');
      this.marquerChampsCommeTouches(this.formReset);
      return;
    }

    if (!this.utilisateurSelectionne?.id) {
      console.error('‚ùå Aucun utilisateur s√©lectionn√© pour reset');
      return;
    }

    // V√©rification suppl√©mentaire de la correspondance des mots de passe
    if (!this.passwordsMatch) {
      this.afficherNotificationErreur('Les mots de passe ne correspondent pas');
      return;
    }

    const id = this.utilisateurSelectionne.id;
    const nouveauMotDePasse = this.formReset.value.newPassword;
    const nomComplet = `${this.utilisateurSelectionne.nom} ${this.utilisateurSelectionne.prenom}`;

    // Utiliser la nouvelle fonction de confirmation personnalis√©e
    if (!this.confirmerResetMotDePasse(nomComplet)) {
      return;
    }

    console.log('üîÑ Reset mot de passe utilisateur :', id);

    this.adminService.reinitialiserMotDePasse(id, nouveauMotDePasse).subscribe({
      next: (response) => {
        console.log('‚úÖ Mot de passe r√©initialis√© avec succ√®s');
        
        // Recharger l'historique pour voir la nouvelle action
        this.chargerHistorique();
        
        // Fermer le formulaire
        this.fermerFormulaire();
        
        // Afficher notification de succ√®s
        this.afficherNotificationSucces(
          `üîë Mot de passe r√©initialis√© avec succ√®s pour ${nomComplet}`
        );
      },
      error: (err) => {
        console.error('‚ùå Erreur reset mot de passe :', err);
        this.afficherNotificationErreur(
          err.error?.message || 'Erreur lors de la r√©initialisation du mot de passe'
        );
      }
    });
  }

  /**
   * ‚úÖ Toggle l'activation/d√©sactivation d'un utilisateur
   */
  toggleActivation(user: any): void {
    if (!user || !user.id) {
      console.error('‚ùå Utilisateur invalide pour toggle activation');
      return;
    }

    // Emp√™cher la d√©sactivation des admins
    if (user.role === 'ADMIN') {
      this.afficherNotificationErreur('üö´ Impossible de modifier le statut d\'un administrateur');
      return;
    }

    const action = user.actif ? 'd√©sactiver' : 'r√©activer';
    const nomComplet = `${user.nom} ${user.prenom}`;

    // Utiliser la nouvelle fonction de confirmation personnalis√©e
    if (!this.confirmerToggleActivation(nomComplet, action)) {
      return;
    }

    console.log(`üîÑ ${action} utilisateur :`, user.id);

    this.adminService.toggleActivation(user.id).subscribe({
      next: (response) => {
        console.log(`‚úÖ Utilisateur ${action} avec succ√®s`);
        
        // Recharger les donn√©es
        this.chargerDonnees();
        
        // Afficher notification avec emoji appropri√©
        const emoji = user.actif ? 'üîí' : '‚úÖ';
        const actionText = user.actif ? 'd√©sactiv√©' : 'r√©activ√©';
        this.afficherNotificationSucces(
          `${emoji} ${nomComplet} a √©t√© ${actionText} avec succ√®s`
        );
      },
      error: (err) => {
        console.error(`‚ùå Erreur ${action} utilisateur :`, err);
        this.afficherNotificationErreur(
          err.error?.message || `Erreur lors de la ${action.slice(0, -1)}ation de l'utilisateur`
        );
      }
    });
  }

  /**
   * ‚úÖ M√©thodes utilitaires
   */

  /**
   * Marque tous les champs d'un formulaire comme touch√©s pour afficher les erreurs
   */
  private marquerChampsCommeTouches(form: FormGroup): void {
    Object.keys(form.controls).forEach(key => {
      const control = form.get(key);
      if (control) {
        control.markAsTouched();
      }
    });
  }

  /**
   * Affiche une confirmation avant action avec des messages personnalis√©s
   */
  private confirmerAction(message: string): boolean {
    return confirm(message);
  }

  /**
   * ‚úÖ Confirmation personnalis√©e pour la r√©initialisation de mot de passe
   */
  private confirmerResetMotDePasse(nomUtilisateur: string): boolean {
    return confirm(`‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nVoulez-vous vraiment r√©initialiser le mot de passe de ${nomUtilisateur} ?\n\n‚Ä¢ Cette action est irr√©versible\n‚Ä¢ L'utilisateur devra utiliser le nouveau mot de passe\n‚Ä¢ Une notification sera envoy√©e automatiquement\n\nConfirmer la r√©initialisation ?`);
  }

  /**
   * ‚úÖ Confirmation personnalis√©e pour l'activation/d√©sactivation
   */
  private confirmerToggleActivation(nomUtilisateur: string, action: string): boolean {
    const actionText = action === 'd√©sactiver' ? 
      'üîí D√âSACTIVATION' : 
      '‚úÖ R√âACTIVATION';
    
    const warningText = action === 'd√©sactiver' ? 
      '‚Ä¢ L\'utilisateur ne pourra plus se connecter\n‚Ä¢ Ses sessions actives seront ferm√©es\n‚Ä¢ Ses permissions seront suspendues' :
      '‚Ä¢ L\'utilisateur pourra √† nouveau se connecter\n‚Ä¢ Ses permissions seront restaur√©es\n‚Ä¢ Il recevra une notification de r√©activation';

    return confirm(`${actionText}\n\nUtilisateur : ${nomUtilisateur}\n\n${warningText}\n\nConfirmer cette action ?`);
  }

  /**
   * Affiche une notification de succ√®s
   */
  private afficherNotificationSucces(message: string): void {
    // Vous pouvez int√©grer ici un service de notification
    // Pour l'instant, on utilise console.log et alert
    console.log('‚úÖ SUCCESS:', message);
    
    // Optionnel : utiliser un toast/snackbar
    // this.notificationService.success(message);
    
    // Temporaire : alert simple
    alert('‚úÖ ' + message);
  }

  /**
   * Affiche une notification d'erreur
   */
  private afficherNotificationErreur(message: string): void {
    // Vous pouvez int√©grer ici un service de notification
    console.error('‚ùå ERROR:', message);
    
    // Optionnel : utiliser un toast/snackbar
    // this.notificationService.error(message);
    
    // Temporaire : alert simple
    alert('‚ùå ' + message);
  }

  /**
   * ‚úÖ M√©thodes pour les statistiques et helpers
   */

  /**
   * Retourne la couleur du badge selon le r√¥le
   */
  getBadgeRoleClass(role: string): string {
    switch (role) {
      case 'ADMIN':
        return 'bg-blue-100 text-blue-800';
      case 'RESPONSABLE':
        return 'bg-amber-100 text-amber-800';
      case 'AGENT':
        return 'bg-green-100 text-green-800';
      default:
        return 'bg-slate-100 text-slate-800';
    }
  }

  /**
   * Retourne la couleur du badge selon le statut
   */
  getBadgeStatutClass(actif: boolean): string {
    return actif 
      ? 'bg-emerald-100 text-emerald-800' 
      : 'bg-red-100 text-red-800';
  }

  /**
   * Retourne les initiales d'un utilisateur
   */
  getUserInitials(user: any): string {
    if (!user || !user.nom || !user.prenom) return '??';
    return (user.nom[0] + user.prenom[0]).toUpperCase();
  }

  /**
   * Formate une date pour l'affichage
   */
  formatDate(date: string | Date): string {
    if (!date) return 'Date inconnue';
    
    try {
      const dateObj = new Date(date);
      return dateObj.toLocaleDateString('fr-FR', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    } catch (error) {
      console.error('‚ùå Erreur formatage date :', error);
      return 'Date invalide';
    }
  }

  /**
   * V√©rifie si un utilisateur peut √™tre modifi√©
   */
  peutEtreModifie(user: any): boolean {
    return user && user.id && user.role !== 'ADMIN';
  }

  /**
   * V√©rifie si l'utilisateur actuel est admin
   */
  private estAdmin(): boolean {
    const token = localStorage.getItem('access-token');
    if (!token) return false;

    try {
      const payload = token.split('.')[1];
      const decodedPayload = atob(payload);
      const decoded = JSON.parse(decodedPayload);
      return decoded.scope === 'ADMIN';
    } catch (e) {
      console.error('‚ùå Erreur v√©rification admin :', e);
      return false;
    }
  }

  /**
   * ‚úÖ M√©thodes de cycle de vie et nettoyage
   */

  /**
   * Rafra√Æchit toutes les donn√©es du dashboard
   */
  rafraichirDonnees(): void {
    console.log('üîÑ Rafra√Æchissement des donn√©es...');
    this.chargerDonnees();
  }

  /**
   * Exporte la liste des utilisateurs (optionnel)
   */
  exporterUtilisateurs(): void {
    console.log('üì§ Export des utilisateurs...');
    // Impl√©mentation de l'export en CSV ou Excel
    // this.exportService.exporterCSV(this.utilisateurs, 'utilisateurs.csv');
  }

  /**
   * Recherche dans la liste des utilisateurs (optionnel)
   */
  rechercherUtilisateur(terme: string): void {
    console.log('üîç Recherche utilisateur :', terme);
    // Impl√©mentation de la recherche/filtrage
    // this.utilisateursFiltres = this.utilisateurs.filter(u => 
    //   u.nom.toLowerCase().includes(terme.toLowerCase()) ||
    //   u.prenom.toLowerCase().includes(terme.toLowerCase()) ||
    //   u.email.toLowerCase().includes(terme.toLowerCase())
    // );
  }

  /**
   * Cleanup lors de la destruction du composant
   */
  ngOnDestroy(): void {
    // Nettoyer les subscriptions si n√©cessaire
    console.log('üßπ Nettoyage du composant dashboard admin');
  }
}